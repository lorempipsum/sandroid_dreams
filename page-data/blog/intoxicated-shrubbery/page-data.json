{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/intoxicated-shrubbery","result":{"data":{"markdownRemark":{"html":"<h1>Intoxicated Shrubbery</h1>\n<p><img src=\"drunk_trees.jpg\" alt=\"Plotting result\">\n<img src=\"drunk_trees_closeup.jpg\" alt=\"Plotting result closeup\"></p>\n<p>This plotting was inspired by some shrubbery I saw on The Downs in Bristol. All of the thick shrubs seemed to grow in a nice parabolic arc, with the tallest branches growing from the center, and the height decreasing smoothly the further you went from the middle. The perfect simple rules to have a computer follow. The basic algorithm is as follows:</p>\n<ol>\n<li>Choose a point on the bottom edge of the page to start a branch.</li>\n</ol>\n<pre><code class=\"language-Java\">int delta = int(random(-3000,2000));\ni=0;\nx= xMax;\ny = int(HORIZONTAL_CENTER + delta);\n</code></pre>\n<ol start=\"2\">\n<li>\n<p>Depending on the distance of the point from the horizontal center, choose a random <em>mass</em> for the branch. The further from the middle, the smaller the <em>mass</em>.</p>\n<pre><code class=\"language-Java\">mass = int(random(8, 180 - abs(delta)/12)); // Quick solution with trial and error. You could do better by using a formula for a curve.\n</code></pre>\n</li>\n<li>\n<p>Choose a new point, a random distance away from the last point. The point has a bias towards negative x (up on the sheet), so the branches grow upwards.</p>\n<pre><code class=\"language-Java\">  x = int(x + spacing*random(-2, 1));\n  y = int(y + spacing*random(-1, 1));\n</code></pre>\n</li>\n<li>\n<p>Draw a line between the original point and the new point, and increase mass used by 1.</p>\n<pre><code class=\"language-Java\">  i=0;\n</code></pre>\n</li>\n<li>\n<p>Repeat steps 3 and 4 until either all the <em>mass</em> has been used up, or the branch goes out of bounds of the drawing area.</p>\n<pre><code class=\"language-Java\">  if ( x > xMin &#x26;&#x26; x &#x3C; xMax &#x26;&#x26; y > yMin &#x26;&#x26; y &#x3C; yMax &#x26;&#x26; i &#x3C; mass &#x26;&#x26; iterations &#x3C; MAX_ITERATIONS) {\n      line_clipped(x0, y0, x, y, up); // draws lines only if they're in the reduced drawing area\n      i=i+1; // increase mass used\n      up = false;\n  }\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"language-Java\">void draw() {\n  int spacing = 100;\n  int x0, y0;\n  int MAX_ITERATIONS = 300;\n\n  x0 = x;\n  y0 = y;\n\n  x = int(x + spacing*random(-2, 1));\n  y = int(y + spacing*random(-1, 1));\n\n  if ( x > xMin &#x26;&#x26; x &#x3C; xMax &#x26;&#x26; y > yMin &#x26;&#x26; y &#x3C; yMax &#x26;&#x26; i &#x3C; mass &#x26;&#x26; iterations &#x3C; MAX_ITERATIONS) {\n      line_clipped(x0, y0, x, y, up); // draws lines only if they're in the reduced drawing area\n      i=i+1;\n      up = false;\n\n  } else {\n    int delta = int(random(-3000,2000));\n    i=0;\n    x= xMax;\n    y = int(HORIZONTAL_CENTER + delta);\n    mass = int(random(8, 180 - abs(delta)/12)); // Hacky way of getting shorter branches when they start nearer to the edge\n    iterations = iterations + 1;\n    up = true; // lift the pen if a branch is finished\n\n    int pen = round(random(1, 2));\n    if (pen != currentPen) {\n      plotter.write(\"SP\"+ pen + \";\", 3000); //Select pen\n      plotter.write(\"PU\"+x+\",\"+y+\";\", 4000); //Position pen\n      println(\"pen: \" + pen);\n    }\n    currentPen = pen;\n\n  }\n\n  if (iterations == MAX_ITERATIONS) {\n      plotter.write(\"PU\"+0+\",\"+0+\";\"); //Position pen at origin when done plotting\n\n  }\n\n}\n</code></pre>\n<p>And that's it!</p>\n<p>Complete Processing code with all of the surrounding stuff:</p>\n<pre><code class=\"language-Java\">  import processing.serial.*;\n\n  Serial myPort;    // Create object from Serial class\n  Plotter plotter;  // Create a plotter object\n  int val;          // Data received from the serial port\n  int lf = 10;      // ASCII linefeed\n\n  //Enable plotting?\n  boolean PLOTTING_ENABLED = true;\n  boolean draw_box = false;\n  boolean draw_label = true;\n  boolean up = true;\n\n  boolean just_draw = false;\n\n\n  //Label\n  String dateTime = day() + \"/\" + month() + \"/\" + year() + \" \" + hour() + \":\" + minute() + \":\" + second() + \" - \";\n  String label = dateTime + \"INTOXICATED SHRUBBERY IV\";\n\n  //Plotter dimensions\n  int xMin = 600;\n  int yMin = 800;\n  int xMax = 10300 - 300;\n  int yMax = 8400 - 600;\n  int A4_MAX_WIDTH = 10887;\n  int A4_MAX_HEIGHT = 8467;\n  int VERTICAL_CENTER = (xMax + xMin) /2;\n  int HORIZONTAL_CENTER = (yMax + yMin) /2;\n\n\n  int i = 0;\n  int iterations = 0;\n  int lastY = yMin;\n  int currentPen = 1;\n\n  int x = -9999999;\n  int y = -9999999;\n  int mass = 50;\n\n  //Let's set this up\n  void setup() {\n    print(dateTime);\n    background(233, 233, 220);\n    size(840, 1080);\n    smooth();\n\n    if (just_draw) {\n      draw_box = false;\n      draw_label = false;\n      PLOTTING_ENABLED = true;\n    }\n\n    //Select a serial port\n    println(Serial.list()); //Print all serial ports to the console\n    String portName = Serial.list()[1]; //make sure you pick the right one\n    println(\"Plotting to port: \" + portName);\n\n    //Open the port\n    myPort = new Serial(this, portName, 9600);\n    myPort.bufferUntil(lf);\n\n    //Associate with a plotter object\n    plotter = new Plotter(myPort);\n\n    //Initialize plotter\n    plotter.write(\"IN;SP2;\");\n    //Draw a label first (this is pretty cool to watch)\n\n    if (draw_label) {\n    int labelX = xMax + 300;\n    int labelY = yMin;\n\n    if (PLOTTING_ENABLED) {\n      plotter.write(\"PU\"+labelX+\",\"+labelY+\";\"); //Position pen\n      plotter.write(\"SI0.14,0.14;DI0,1;LB\" + label + char(3)); //Draw label\n      println(\"drawing label\");\n      delay(label.length() * 500);\n      println(\"label done\");\n    }\n\n    fill(50);\n    float textX = map(labelX, 0, A4_MAX_HEIGHT, 0, width);\n    float textY = map(labelY, 0, A4_MAX_WIDTH, 0, height);\n\n    text(dateTime + label, textY, textX);\n    }\n\n    if (draw_box) {\n\n      //box\n      drawLine(xMin, yMin, xMax, yMin, true);\n      drawLine(xMax, yMin, xMax, yMax, true);\n      drawLine(xMax, yMax, xMin, yMax, true);\n      drawLine(xMin, yMax, xMin, yMin, true);\n\n      // diagonals\n      drawLine(xMin, yMin, xMax, yMax, true);\n      drawLine(xMin, yMax, xMax, yMin, true);\n\n      //vertical line down from middle\n      line_clipped(xMin, (yMax + yMin) /2, xMax, (yMax + yMin) /2, true);\n\n      //horizontal line\n      line_clipped((xMax + xMin) /2, yMin, (xMax + xMin) /2, yMax, true);\n    }\n\n  }\n\n  void draw() {\n    int spacing = 100;\n    int x0, y0;\n    int MAX_ITERATIONS = 150;\n\n    //horizontal line\n    x0 = x;\n    y0 = y;\n\n    x = int(x + spacing*random(-2, 1));\n    y = int(y + spacing*random(-1, 1));\n\n    if ( x > xMin &#x26;&#x26; x &#x3C; xMax &#x26;&#x26; y > yMin &#x26;&#x26; y &#x3C; yMax &#x26;&#x26; i &#x3C; mass &#x26;&#x26; iterations &#x3C; MAX_ITERATIONS) {\n        line_clipped(x0, y0, x, y, up);\n        i=i+1;\n        up = false;\n\n    } else {\n\n      int delta = int(random(-3000,2000));\n      println(\"delta=\" + delta);\n      x = int(VERTICAL_CENTER + random(-5, 5));\n      y = int(HORIZONTAL_CENTER + delta);\n      x= xMax;\n      i=0;\n      mass = int(random(8, 180 - abs(delta)/12));\n      println(iterations);\n      iterations = iterations + 1;\n      up = true;\n\n      int pen = round(random(1, 2));\n      currentPen = pen;\n      if (pen != currentPen) {\n        plotter.write(\"SP\"+ pen + \";\", 3000); //Select pen\n        plotter.write(\"PU\"+x+\",\"+y+\";\", 4000); //Position pen\n        println(\"pen: \" + pen);\n      }\n\n\n    }\n\n    if (iterations == MAX_ITERATIONS) {\n        plotter.write(\"PU\"+0+\",\"+0+\";\"); //Position pen\n    }\n\n  }\n  /*\n  * Encode a given point (x, y) into the different regions of\n  * a clip window as specified by its top-left corner (cx, cy)\n  * and it's width and height (cw, ch).\n  */\n  int encode_endpoint(\n    float x, float y,\n    float clipx, float clipy, float clipw, float cliph)\n  {\n    int code = 0; /* Initialized to being inside clip window */\n\n    /* Calculate the min and max coordinates of clip window */\n    float xmin = clipx;\n    float xmax = clipx + cliph;\n    float ymin = clipy;\n    float ymax = clipy + clipw;\n\n    if (x &#x3C; xmin)       /* to left of clip window */\n      code |= (1 &#x3C;&#x3C; 0);\n    else if (x > xmax)  /* to right of clip window */\n      code |= (1 &#x3C;&#x3C; 1);\n\n    if (y &#x3C; ymin)       /* below clip window */\n      code |= (1 &#x3C;&#x3C; 2);\n    else if (y > ymax)  /* above clip window */\n      code |= (1 &#x3C;&#x3C; 3);\n\n    return code;\n  }\n\n  boolean line_clipped(\n    float x0, float y0, float x1, float y1, boolean up) {\n\n    float clipx = xMin;\n    float clipy = yMin;\n    float clipw = yMax-yMin;\n    float cliph = xMax-xMin;\n\n\n\n    /* Stores encodings for the two endpoints of our line */\n    int e0code, e1code;\n\n    /* Whether the line should be drawn or not */\n    boolean accept = false;\n    int tries = 0;\n\n    do {\n      /* Get encodings for the two endpoints of our line */\n      e0code = encode_endpoint(x0, y0, clipx, clipy, clipw, cliph);\n      e1code = encode_endpoint(x1, y1, clipx, clipy, clipw, cliph);\n      tries = tries + 1;\n      if (tries > 3) {\n        println(\"tried too many times;\");\n        break;\n      }\n\n      if (e0code == 0 &#x26;&#x26; e1code == 0) {\n        /* If line inside window, accept and break out of loop */\n        accept = true;\n        break;\n      } else if ((e0code &#x26; e1code) != 0) {\n        /*\n        * If the bitwise AND is not 0, it means both points share\n        * an outside zone. Leave accept as 'false' and exit loop.\n        */\n        break;\n      } else {\n        /* Pick an endpoint that is outside the clip window */\n        int code = e0code != 0 ? e0code : e1code;\n\n        float newx = 0, newy = 0;\n\n        /*\n        * Now figure out the new endpoint that needs to replace\n        * the current one. Each of the four cases are handled\n        * separately.\n        */\n        if ((code &#x26; (1 &#x3C;&#x3C; 0)) != 0) {\n          /* Endpoint is to the left of clip window */\n          //println(\"/* Endpoint is above the clip window */\");\n\n          newx = xMin;\n          newy = ((y1 - y0) / (x1 - x0)) * (newx - x0) + y0;\n        } else if ((code &#x26; (1 &#x3C;&#x3C; 1)) != 0) {\n          /* Endpoint is to the right of clip window */\n          //println(\"/* Endpoint is below the clip window */\");\n\n          newx = xMax;\n          newy = ((y1 - y0) / (x1 - x0)) * (newx - x0) + y0;\n        } else if ((code &#x26; (1 &#x3C;&#x3C; 3)) != 0) {\n          /* Endpoint is above the clip window */\n          //println(\"/* Endpoint is to the right of the clip window */\");\n          newy = yMax;\n          newx = ((x1 - x0) / (y1 - y0)) * (newy - y0) + x0;\n        } else if ((code &#x26; (1 &#x3C;&#x3C; 2)) != 0) {\n          /* Endpoint is below the clip window */\n          //println(\" /* Endpoint is to the left of the clip window */\");\n          newy = yMin;\n          newx = ((x1 - x0) / (y1 - y0)) * (newy - y0) + x0;\n        }\n\n        /* Now we replace the old endpoint depending on which we chose */\n        if (code == e0code) {\n          x0 = newx;\n          y0 = newy;\n        } else {\n          x1 = newx;\n          y1 = newy;\n        }\n        tries = tries +1;\n      }\n    } while (true);\n\n\n    if (accept) {\n      drawLine(x0, y0, x1, y1, up);\n    }\n\n    return accept;\n  }\n\n  void drawLine(float x1, float y1, float x2, float y2, boolean up) {\n    float _x1 = map(x1, 0, A4_MAX_HEIGHT, 0, width);\n    float _y1 = map(y1, 0, A4_MAX_WIDTH, 0, height);\n\n    float _x2 = map(x2, 0, A4_MAX_HEIGHT, 0, width);\n    float _y2 = map(y2, 0, A4_MAX_WIDTH, 0, height);\n    line(_y1, _x1, _y2, _x2);\n\n    String pen = \"PD\";\n    if (up) {\n      pen=\"PU\";\n    }\n\n\n    plotter.write(pen+x1+\",\"+y1+\";\");\n    plotter.write(\"PD\"+x2+\",\"+y2+\";\"); //75 ms delay\n\n    if (PLOTTING_ENABLED) {\n      delay(200);\n    }\n  }\n\n  void drawPoint(int x, int y) {\n    float _x = map(x, 0, A4_MAX_HEIGHT, 0, width);\n    float _y = map(y, 0, A4_MAX_WIDTH, 0, height);\n\n    plotter.write(\"PU\"+x+\",\"+y+\";\"); //Position pen\n    plotter.write(\"PD\"+x+\",\"+y+\";\"); //Position pen\n\n    point(_y, _x);\n    if (PLOTTING_ENABLED) {\n      delay(250);\n    }\n  }\n\n\n\n  /*************************\n  Simple plotter class\n  *************************/\n\n  class Plotter {\n    Serial port;\n\n    Plotter(Serial _port) {\n      port = _port;\n    }\n\n    void write(String hpgl) {\n      if (PLOTTING_ENABLED) {\n        port.write(hpgl);\n      }\n    }\n\n    void write(String hpgl, int del) {\n      if (PLOTTING_ENABLED) {\n        port.write(hpgl);\n        delay(del);\n      }\n    }\n  }\n</code></pre>","frontmatter":{"date":"December 24, 2020","slug":"/blog/intoxicated-shrubbery","title":"Intoxicated Shrubbery"}}},"pageContext":{"slug":"/blog/intoxicated-shrubbery"}},"staticQueryHashes":[]}