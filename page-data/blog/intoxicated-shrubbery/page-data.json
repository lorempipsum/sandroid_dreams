{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/intoxicated-shrubbery","result":{"data":{"markdownRemark":{"html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/aa5593aef83d44772bcba35905c5498d/56d81/drunk_trees.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 130.99999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgT/xAAWAQEBAQAAAAAAAAAAAAAAAAABAAL/2gAMAwEAAhADEAAAAe4WdFRESlbSsCP/xAAZEAACAwEAAAAAAAAAAAAAAAABIAIQIRH/2gAIAQEAAQUCQGpHO6n/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ak//xAAZEAEAAwEBAAAAAAAAAAAAAAABABARIGH/2gAIAQEAAT8hhzCeoYkdKK//2gAMAwEAAgADAAAAEGj2gP/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/ECn/xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QIOT/xAAaEAADAQADAAAAAAAAAAAAAAAAAREhEEFR/9oACAEBAAE/EKNbOOhlaExyjx0aUxykh+oSXiEW4uP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Plotting result\"\n        title=\"Plotting result\"\n        src=\"/static/aa5593aef83d44772bcba35905c5498d/4b190/drunk_trees.jpg\"\n        srcset=\"/static/aa5593aef83d44772bcba35905c5498d/e07e9/drunk_trees.jpg 200w,\n/static/aa5593aef83d44772bcba35905c5498d/066f9/drunk_trees.jpg 400w,\n/static/aa5593aef83d44772bcba35905c5498d/4b190/drunk_trees.jpg 800w,\n/static/aa5593aef83d44772bcba35905c5498d/e5166/drunk_trees.jpg 1200w,\n/static/aa5593aef83d44772bcba35905c5498d/b17f8/drunk_trees.jpg 1600w,\n/static/aa5593aef83d44772bcba35905c5498d/56d81/drunk_trees.jpg 2117w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>I was lying in the park on a sunny afternoon trying to\nthink of ideas of what to plot on my recently acquired HP7475A. There wasn't much there besides some grass, a few trees and some\nshrubs. Plotting a whole tree I thought is much too difficult. But the shrubs seemed doable - all of the thick shrubs\nseemed to grow in a nice parabolic arc, with the tallest branches growing from the center, and the height decreasing\nsmoothly the further you went from the middle.</p>\n<p>Here's the rough sketch I made in the park so I wouldn't forget (I think the drawings on the left are dandelion-inspired\nideas that are yet to be realized):</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/db5e8d76694df4be01d7b352c3c71ef3/d9f85/intoxicated_shrubbery_sketch.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHRpKxosP/EABcQAAMBAAAAAAAAAAAAAAAAAAAREiD/2gAIAQEAAQUCZQ8f/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8Ci//EABgQAAMBAQAAAAAAAAAAAAAAAAABETFR/9oACAEBAAE/IW/WmBUjSPpT/9oADAMBAAIAAwAAABDQD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAAIDAAMBAAAAAAAAAAAAAAERACExUWFxkf/aAAgBAQABPxD3CUs58huIZsjFkGwQhnf2EBgGr3qf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Initial Sketch\"\n        title=\"Initial Sketch\"\n        src=\"/static/db5e8d76694df4be01d7b352c3c71ef3/4b190/intoxicated_shrubbery_sketch.jpg\"\n        srcset=\"/static/db5e8d76694df4be01d7b352c3c71ef3/e07e9/intoxicated_shrubbery_sketch.jpg 200w,\n/static/db5e8d76694df4be01d7b352c3c71ef3/066f9/intoxicated_shrubbery_sketch.jpg 400w,\n/static/db5e8d76694df4be01d7b352c3c71ef3/4b190/intoxicated_shrubbery_sketch.jpg 800w,\n/static/db5e8d76694df4be01d7b352c3c71ef3/e5166/intoxicated_shrubbery_sketch.jpg 1200w,\n/static/db5e8d76694df4be01d7b352c3c71ef3/b17f8/intoxicated_shrubbery_sketch.jpg 1600w,\n/static/db5e8d76694df4be01d7b352c3c71ef3/d9f85/intoxicated_shrubbery_sketch.jpg 2887w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>It's a random walk, starting from the bottom and moving in a random direction at each \"step\" - except the step size\nis larger if the random choice is directed upwards. The total length (\"mass\") of each\nbranch is decided semi-randomly at the beginning, and is higher near the horizontal center of the page than the edges.</p>\n<p>Here's a more detailed breakdown with some code: </p>\n<ol>\n<li>\n<p>Choose a point on the bottom edge of the page to start a branch.</p>\n<pre><code class=\"language-Java\">int delta = int(random(-3000,2000));\ni=0;\nx= xMax;\ny = int(HORIZONTAL_CENTER + delta);\n</code></pre>\n</li>\n<li>\n<p>Depending on the distance of the point from the horizontal center, choose a random <em>mass</em> for the branch. The further\nfrom the middle, the smaller the <em>mass</em>.</p>\n<pre><code class=\"language-Java\">mass = int(random(8, 180 - abs(delta)/12)); // Quick solution with trial and error. You could do better by using a formula for a curve.\n</code></pre>\n</li>\n<li>\n<p>Choose a new point, a random distance away from the last point. The point has a bias towards negative x (up on the\nsheet), so the branches grow upwards.</p>\n<pre><code class=\"language-Java\">  x = int(x + spacing*random(-2, 1));\n  y = int(y + spacing*random(-1, 1));\n</code></pre>\n</li>\n<li>\n<p>Draw a line between the original point and the new point, and increase mass used by 1.</p>\n<pre><code class=\"language-Java\">  i = i + 1;\n</code></pre>\n</li>\n<li>\n<p>Repeat steps 3 and 4 until either all the <em>mass</em> has been used up, or the branch goes out of bounds of the drawing\narea.</p>\n<pre><code class=\"language-Java\">  if ( x > xMin &#x26;&#x26; x &#x3C; xMax &#x26;&#x26; y > yMin &#x26;&#x26; y &#x3C; yMax &#x26;&#x26; i &#x3C; mass &#x26;&#x26; iterations &#x3C; MAX_ITERATIONS) {\n      line_clipped(x0, y0, x, y, up);\n      i = i + 1; // increase mass used\n  }\n</code></pre>\n</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bc2d4ef48d4f8c0febd1ff08f65bd913/9568a/drunk_trees_closeup.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 133.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAMBAgQF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHqLopdplNSZeZqhof/xAAbEAACAwADAAAAAAAAAAAAAAAAAQIREgMgIf/aAAgBAQABBQIv0nKhs2PjswYXT//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABcRAQEBAQAAAAAAAAAAAAAAAAABERL/2gAIAQIBAT8BkctbX//EABUQAQEAAAAAAAAAAAAAAAAAACBB/9oACAEBAAY/AlV//8QAHRAAAgIBBQAAAAAAAAAAAAAAAAERMUEgIVFxgf/aAAgBAQABPyGREnsYllDymKEpiLS9LZgUXPej/9oADAMBAAIAAwAAABB//L7/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxAp/8QAFxEBAQEBAAAAAAAAAAAAAAAAAAERYf/aAAgBAgEBPxDZtKdn/8QAHRAAAgICAwEAAAAAAAAAAAAAAREAIRBBMWFxkf/aAAgBAQABPxApzEI+So1oFgVK87jrhc6IO4EyFdXqGCwDpIAemaYUHt8AcDH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Plotting result closeup\"\n        title=\"Plotting result closeup\"\n        src=\"/static/bc2d4ef48d4f8c0febd1ff08f65bd913/4b190/drunk_trees_closeup.jpg\"\n        srcset=\"/static/bc2d4ef48d4f8c0febd1ff08f65bd913/e07e9/drunk_trees_closeup.jpg 200w,\n/static/bc2d4ef48d4f8c0febd1ff08f65bd913/066f9/drunk_trees_closeup.jpg 400w,\n/static/bc2d4ef48d4f8c0febd1ff08f65bd913/4b190/drunk_trees_closeup.jpg 800w,\n/static/bc2d4ef48d4f8c0febd1ff08f65bd913/e5166/drunk_trees_closeup.jpg 1200w,\n/static/bc2d4ef48d4f8c0febd1ff08f65bd913/b17f8/drunk_trees_closeup.jpg 1600w,\n/static/bc2d4ef48d4f8c0febd1ff08f65bd913/9568a/drunk_trees_closeup.jpg 3024w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<pre><code class=\"language-Java\">void draw() {\n  int spacing = 100;\n  int x0, y0;\n  int MAX_ITERATIONS = 300;\n\n  x0 = x;\n  y0 = y;\n\n  x = int(x + spacing*random(-2, 1));\n  y = int(y + spacing*random(-1, 1));\n\n  if ( x > xMin &#x26;&#x26; x &#x3C; xMax &#x26;&#x26; y > yMin &#x26;&#x26; y &#x3C; yMax &#x26;&#x26; i &#x3C; mass &#x26;&#x26; iterations &#x3C; MAX_ITERATIONS) {\n      line_clipped(x0, y0, x, y, up); // draws lines only if they're in the reduced drawing area\n      i=i+1;\n      up = false;\n\n  } else {\n    int delta = int(random(-3000,2000));\n    i=0;\n    x= xMax;\n    y = int(HORIZONTAL_CENTER + delta);\n    mass = int(random(8, 180 - abs(delta)/12)); // Hacky way of getting shorter branches when they start nearer to the edge\n    iterations = iterations + 1;\n    up = true; // lift the pen if a branch is finished\n\n    int pen = round(random(1, 2));\n    if (pen != currentPen) {\n      plotter.write(\"SP\"+ pen + \";\", 3000); //Select pen\n      plotter.write(\"PU\"+x+\",\"+y+\";\", 4000); //Position pen\n      println(\"pen: \" + pen);\n    }\n    currentPen = pen;\n\n  }\n\n  if (iterations == MAX_ITERATIONS) {\n      plotter.write(\"PU\"+0+\",\"+0+\";\"); //Position pen at origin when done plotting\n\n  }\n\n}\n</code></pre>\n<p>   And that's it!</p>\n<p>   Complete Processing code with all of the surrounding stuff:</p>\n<pre><code class=\"language-Java\">  import processing.serial.*;\n\n  Serial myPort;    // Create object from Serial class\n  Plotter plotter;  // Create a plotter object\n  int val;          // Data received from the serial port\n  int lf = 10;      // ASCII linefeed\n\n  //Enable plotting?\n  boolean PLOTTING_ENABLED = true;\n  boolean draw_box = false;\n  boolean draw_label = true;\n  boolean up = true;\n\n  boolean just_draw = false;\n\n\n  //Label\n  String dateTime = day() + \"/\" + month() + \"/\" + year() + \" \" + hour() + \":\" + minute() + \":\" + second() + \" - \";\n  String label = dateTime + \"INTOXICATED SHRUBBERY IV\";\n\n  //Plotter dimensions\n  int xMin = 600;\n  int yMin = 800;\n  int xMax = 10300 - 300;\n  int yMax = 8400 - 600;\n  int A4_MAX_WIDTH = 10887;\n  int A4_MAX_HEIGHT = 8467;\n  int VERTICAL_CENTER = (xMax + xMin) /2;\n  int HORIZONTAL_CENTER = (yMax + yMin) /2;\n\n\n  int i = 0;\n  int iterations = 0;\n  int lastY = yMin;\n  int currentPen = 1;\n\n  int x = -9999999;\n  int y = -9999999;\n  int mass = 50;\n\n  //Let's set this up\n  void setup() {\n    print(dateTime);\n    background(233, 233, 220);\n    size(840, 1080);\n    smooth();\n\n    if (just_draw) {\n      draw_box = false;\n      draw_label = false;\n      PLOTTING_ENABLED = true;\n    }\n\n    //Select a serial port\n    println(Serial.list()); //Print all serial ports to the console\n    String portName = Serial.list()[1]; //make sure you pick the right one\n    println(\"Plotting to port: \" + portName);\n\n    //Open the port\n    myPort = new Serial(this, portName, 9600);\n    myPort.bufferUntil(lf);\n\n    //Associate with a plotter object\n    plotter = new Plotter(myPort);\n\n    //Initialize plotter\n    plotter.write(\"IN;SP2;\");\n    //Draw a label first (this is pretty cool to watch)\n\n    if (draw_label) {\n    int labelX = xMax + 300;\n    int labelY = yMin;\n\n    if (PLOTTING_ENABLED) {\n      plotter.write(\"PU\"+labelX+\",\"+labelY+\";\"); //Position pen\n      plotter.write(\"SI0.14,0.14;DI0,1;LB\" + label + char(3)); //Draw label\n      println(\"drawing label\");\n      delay(label.length() * 500);\n      println(\"label done\");\n    }\n\n    fill(50);\n    float textX = map(labelX, 0, A4_MAX_HEIGHT, 0, width);\n    float textY = map(labelY, 0, A4_MAX_WIDTH, 0, height);\n\n    text(dateTime + label, textY, textX);\n    }\n\n    if (draw_box) {\n\n      //box\n      drawLine(xMin, yMin, xMax, yMin, true);\n      drawLine(xMax, yMin, xMax, yMax, true);\n      drawLine(xMax, yMax, xMin, yMax, true);\n      drawLine(xMin, yMax, xMin, yMin, true);\n\n      // diagonals\n      drawLine(xMin, yMin, xMax, yMax, true);\n      drawLine(xMin, yMax, xMax, yMin, true);\n\n      //vertical line down from middle\n      line_clipped(xMin, (yMax + yMin) /2, xMax, (yMax + yMin) /2, true);\n\n      //horizontal line\n      line_clipped((xMax + xMin) /2, yMin, (xMax + xMin) /2, yMax, true);\n    }\n\n  }\n\n  void draw() {\n    int spacing = 100;\n    int x0, y0;\n    int MAX_ITERATIONS = 150;\n\n    //horizontal line\n    x0 = x;\n    y0 = y;\n\n    x = int(x + spacing*random(-2, 1));\n    y = int(y + spacing*random(-1, 1));\n\n    if ( x > xMin &#x26;&#x26; x &#x3C; xMax &#x26;&#x26; y > yMin &#x26;&#x26; y &#x3C; yMax &#x26;&#x26; i &#x3C; mass &#x26;&#x26; iterations &#x3C; MAX_ITERATIONS) {\n        line_clipped(x0, y0, x, y, up);\n        i=i+1;\n        up = false;\n\n    } else {\n\n      int delta = int(random(-3000,2000));\n      println(\"delta=\" + delta);\n      x = int(VERTICAL_CENTER + random(-5, 5));\n      y = int(HORIZONTAL_CENTER + delta);\n      x= xMax;\n      i=0;\n      mass = int(random(8, 180 - abs(delta)/12));\n      println(iterations);\n      iterations = iterations + 1;\n      up = true;\n\n      int pen = round(random(1, 2));\n      currentPen = pen;\n      if (pen != currentPen) {\n        plotter.write(\"SP\"+ pen + \";\", 3000); //Select pen\n        plotter.write(\"PU\"+x+\",\"+y+\";\", 4000); //Position pen\n        println(\"pen: \" + pen);\n      }\n\n\n    }\n\n    if (iterations == MAX_ITERATIONS) {\n        plotter.write(\"PU\"+0+\",\"+0+\";\"); //Position pen\n    }\n\n  }\n  /*\n  * Encode a given point (x, y) into the different regions of\n  * a clip window as specified by its top-left corner (cx, cy)\n  * and it's width and height (cw, ch).\n  */\n  int encode_endpoint(\n    float x, float y,\n    float clipx, float clipy, float clipw, float cliph)\n  {\n    int code = 0; /* Initialized to being inside clip window */\n\n    /* Calculate the min and max coordinates of clip window */\n    float xmin = clipx;\n    float xmax = clipx + cliph;\n    float ymin = clipy;\n    float ymax = clipy + clipw;\n\n    if (x &#x3C; xmin)       /* to left of clip window */\n      code |= (1 &#x3C;&#x3C; 0);\n    else if (x > xmax)  /* to right of clip window */\n      code |= (1 &#x3C;&#x3C; 1);\n\n    if (y &#x3C; ymin)       /* below clip window */\n      code |= (1 &#x3C;&#x3C; 2);\n    else if (y > ymax)  /* above clip window */\n      code |= (1 &#x3C;&#x3C; 3);\n\n    return code;\n  }\n\n  boolean line_clipped(\n    float x0, float y0, float x1, float y1, boolean up) {\n\n    float clipx = xMin;\n    float clipy = yMin;\n    float clipw = yMax-yMin;\n    float cliph = xMax-xMin;\n\n\n\n    /* Stores encodings for the two endpoints of our line */\n    int e0code, e1code;\n\n    /* Whether the line should be drawn or not */\n    boolean accept = false;\n    int tries = 0;\n\n    do {\n      /* Get encodings for the two endpoints of our line */\n      e0code = encode_endpoint(x0, y0, clipx, clipy, clipw, cliph);\n      e1code = encode_endpoint(x1, y1, clipx, clipy, clipw, cliph);\n      tries = tries + 1;\n      if (tries > 3) {\n        println(\"tried too many times;\");\n        break;\n      }\n\n      if (e0code == 0 &#x26;&#x26; e1code == 0) {\n        /* If line inside window, accept and break out of loop */\n        accept = true;\n        break;\n      } else if ((e0code &#x26; e1code) != 0) {\n        /*\n        * If the bitwise AND is not 0, it means both points share\n        * an outside zone. Leave accept as 'false' and exit loop.\n        */\n        break;\n      } else {\n        /* Pick an endpoint that is outside the clip window */\n        int code = e0code != 0 ? e0code : e1code;\n\n        float newx = 0, newy = 0;\n\n        /*\n        * Now figure out the new endpoint that needs to replace\n        * the current one. Each of the four cases are handled\n        * separately.\n        */\n        if ((code &#x26; (1 &#x3C;&#x3C; 0)) != 0) {\n          /* Endpoint is to the left of clip window */\n          //println(\"/* Endpoint is above the clip window */\");\n\n          newx = xMin;\n          newy = ((y1 - y0) / (x1 - x0)) * (newx - x0) + y0;\n        } else if ((code &#x26; (1 &#x3C;&#x3C; 1)) != 0) {\n          /* Endpoint is to the right of clip window */\n          //println(\"/* Endpoint is below the clip window */\");\n\n          newx = xMax;\n          newy = ((y1 - y0) / (x1 - x0)) * (newx - x0) + y0;\n        } else if ((code &#x26; (1 &#x3C;&#x3C; 3)) != 0) {\n          /* Endpoint is above the clip window */\n          //println(\"/* Endpoint is to the right of the clip window */\");\n          newy = yMax;\n          newx = ((x1 - x0) / (y1 - y0)) * (newy - y0) + x0;\n        } else if ((code &#x26; (1 &#x3C;&#x3C; 2)) != 0) {\n          /* Endpoint is below the clip window */\n          //println(\" /* Endpoint is to the left of the clip window */\");\n          newy = yMin;\n          newx = ((x1 - x0) / (y1 - y0)) * (newy - y0) + x0;\n        }\n\n        /* Now we replace the old endpoint depending on which we chose */\n        if (code == e0code) {\n          x0 = newx;\n          y0 = newy;\n        } else {\n          x1 = newx;\n          y1 = newy;\n        }\n        tries = tries +1;\n      }\n    } while (true);\n\n\n    if (accept) {\n      drawLine(x0, y0, x1, y1, up);\n    }\n\n    return accept;\n  }\n\n  void drawLine(float x1, float y1, float x2, float y2, boolean up) {\n    float _x1 = map(x1, 0, A4_MAX_HEIGHT, 0, width);\n    float _y1 = map(y1, 0, A4_MAX_WIDTH, 0, height);\n\n    float _x2 = map(x2, 0, A4_MAX_HEIGHT, 0, width);\n    float _y2 = map(y2, 0, A4_MAX_WIDTH, 0, height);\n    line(_y1, _x1, _y2, _x2);\n\n    String pen = \"PD\";\n    if (up) {\n      pen=\"PU\";\n    }\n\n\n    plotter.write(pen+x1+\",\"+y1+\";\");\n    plotter.write(\"PD\"+x2+\",\"+y2+\";\"); //75 ms delay\n\n    if (PLOTTING_ENABLED) {\n      delay(200);\n    }\n  }\n\n  void drawPoint(int x, int y) {\n    float _x = map(x, 0, A4_MAX_HEIGHT, 0, width);\n    float _y = map(y, 0, A4_MAX_WIDTH, 0, height);\n\n    plotter.write(\"PU\"+x+\",\"+y+\";\"); //Position pen\n    plotter.write(\"PD\"+x+\",\"+y+\";\"); //Position pen\n\n    point(_y, _x);\n    if (PLOTTING_ENABLED) {\n      delay(250);\n    }\n  }\n\n\n\n  /*************************\n  Simple plotter class\n  *************************/\n\n  class Plotter {\n    Serial port;\n\n    Plotter(Serial _port) {\n      port = _port;\n    }\n\n    void write(String hpgl) {\n      if (PLOTTING_ENABLED) {\n        port.write(hpgl);\n      }\n    }\n\n    void write(String hpgl, int del) {\n      if (PLOTTING_ENABLED) {\n        port.write(hpgl);\n        delay(del);\n      }\n    }\n  }\n</code></pre>","frontmatter":{"date":"December 24, 2020","slug":"/blog/intoxicated-shrubbery","title":"Intoxicated Shrubbery"}}},"pageContext":{"slug":"/blog/intoxicated-shrubbery"}},"staticQueryHashes":[]}